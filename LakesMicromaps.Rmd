---
title: "LakeMicromaps"
author: "Marc Weber"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    theme: yeti
    highlighted: default 
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Workaround step to associate lakes with aggregated ecoregions
```{r, eval=FALSE}
library(rgdal); library(rgeos);library(GISTools)
lakes = readOGR('H:/NHDPlusV21/NHDPlusNationalData/NHDPlusV21_National_Seamless.gdb','NHDWaterbody')
levels(lakes$FTYPE)
lakes = lakes[lakes$FTYPE %in% c('LakePond','Reservoir'),]
lake_cents = coordinates(lakes)
lakes = SpatialPointsDataFrame(coords = lake_cents, data = lakes@data, proj4string = CRS(proj4string(lakes)))

ageco = readOGR('L:/Priv/ARM Data/Omernik_Ecoregions_And_Aggregated_Ecoregions','Aggr_Ecoregions9_2015')
head(ageco@data)
proj4string(ageco)
proj4string(lakes)
lakes = spTransform(lakes, CRS(proj4string(ageco)))

OverUpdate <- function(points, polys) {
      pointpoly = over(points, polys)
      points@data = data.frame(points@data, pointpoly)
}

lakes@data = OverUpdate(lakes, ageco)
head(lakes@data)
# Did we miss any?
if (any(is.na(lakes$WSA9))){
  missing = lakes[is.na(lakes$WSA9),]
  m = gDistance(missing, ageco, byid=TRUE) 
  row = apply(m, 2, function(x) which(x==min(x))) 
  row = sapply(row, "[",1)
  labels = unlist(ageco@data[row,]$WSA9) 
  missing$WSA9 <- labels
  lakes$WSA9[is.na(lakes$WSA9)] = missing$WSA9[match(lakes$COMID[is.na(lakes$WSA9)],missing$COMID)]
  any(is.na(lakes$WSA9))
  lakes$WSA9_NAME[is.na(lakes$WSA9_NAME)] = ageco$WSA9_NAME[match(lakes$WSA9[is.na(lakes$WSA9_NAME)],ageco$WSA9)]
  any(is.na(lakes$WSA9_NAME))
}
save.image("H:/WorkingData/lakes.RData")
```

## Link with some LakeCat data and make example micromap
### Watershed Area
```{r, message=FALSE, error=FALSE}
load("H:/WorkingData/lakes.RData")
#load("//aa.ad.epa.gov/ord/COR/Users/M-Z/mweber/Net MyDocuments/Publications/Wiley StatRef Article/MicromapExample_wsa.RData")
kffact = read.csv('L:/Priv/CORFiles/Geospatial_Library/Data/Project/LakeCat/FinalTables/Kffact_Final.csv')
head(kffact)
table(kffact$inStreamCat)
# Just look at non-network lakes
kffact = kffact[kffact$inStreamCat==0,]
lakedata = kffact[c(1,3)]
rm(kffact)

# # Convert to log scale
lakedata$WsAreaSqKm = log10(lakedata$WsAreaSqKm)

library(micromap)
# create map table
wsa.polys <- create_map_table(ageco, 'WSA9_NAME')
head(wsa.polys)
#change ID from factor to character
levels(as.factor(wsa.polys$ID))
levels(wsa.polys$ID) <- c("Coastal Plains","N. Appalachians","N. Plains","S. Appalachians","S. Plains", 
                          "T. Plains","Upper Midwest","W. Mountains","Xeric")
wsa.polys$ID <- as.character(wsa.polys$ID)
lakedata$WSA_NAME = lakes@data$WSA9_NAME[match(lakedata$COMID, lakes@data$COMID)]
levels(lakedata$WSA_NAME)
levels(lakedata$WSA_NAME) <- c("Coastal Plains","N. Appalachians","N. Plains","S. Appalachians","S. Plains", 
                          "T. Plains","Upper Midwest","W. Mountains","Xeric")

#now summarize data by aggregated ecoregions
#tip from Mike McManus via QuickR blog  http://statmethods.wordpress.com/
# define and name the statistics of interest  
stats <- function(x)(c(N = length(x), Mean = mean(x)))  

# statsq <-function(x)(c(N = length(x), Min = min(x), Q1 = quantile(x,c(.25)),
#                        Median = quantile(x,c(.5)), Q3 = quantile(x,c(.75)),
#                        Max = max(x)))
statsq <-function(x)(c(N = length(x), Min = quantile(x,c(.05)), Q1 = quantile(x,c(.25)),
                       Median = quantile(x,c(.5)), Q3 = quantile(x,c(.75)),
                       Max = quantile(x,c(.95))))

library(reshape)
lakes.dfm   <- melt(lakedata,  
                      #outcome variables  
                      measure.vars = c("WsAreaSqKm"),  
                      # classification variables  
                      id.vars = c("WSA_NAME"),  na.rm=TRUE)


lakes.dfc <- cast(lakes.dfm, WSA_NAME ~ variable, statsq)
names(lakes.dfc) <- c("WSA_NAME","WsAreaSqKm_N","WsAreaSqKm_Min","WsAreaSqKm_Q125","WsAreaSqKm_Median50","WsAreaSqKm_Q375","WsAreaSqKm_Max") 
lakes.dfc$WSA_NAME <- as.character(lakes.dfc$WSA_NAME)

lakes.dfc$points<-0

Wshd_size <- mmplot(stat.data=lakes.dfc, 
       map.data=wsa.polys,
       map.all=T,
       # plot.width=11,
       panel.types=c('map', 'labels', 'box_summary'),
       panel.data=list(NA,
                       "WSA_NAME",
                       list("WsAreaSqKm_Min","WsAreaSqKm_Q125","WsAreaSqKm_Median50","WsAreaSqKm_Q375","WsAreaSqKm_Max")),
       ord.by="WsAreaSqKm_Median50", 
       grouping=3, 
       median.row=F, 
       map.link=c("WSA_NAME", 'ID'), 
       panel.att=list(list(1, header='Light Gray Means\n Highlighted Above'), 
#                            inactive.border.color=gray(.7), 
#                            inactive.border.size=2), 
                      
                  list(2, header='Aggregated\n Ecoregions', 
                       align='left', text.size=.6),
                  
                  list(3, header='Watershed Area Sq. KM',
                       graph.bgcolor='lightgray',
                       graph.bar.size = .6)))
print(Wshd_size, name='Wshd_size.png',res=1200)
```

### Soil Erodibility, Impervious Surfaces, and Road Density for all lakes
```{r, message=FALSE, error=FALSE}
load("H:/WorkingData/lakes.RData")
#load("//aa.ad.epa.gov/ord/COR/Users/M-Z/mweber/Net MyDocuments/Publications/Wiley StatRef Article/MicromapExample_wsa.RData")
kffact = read.csv('L:/Priv/CORFiles/Geospatial_Library/Data/Project/LakeCat/FinalTables/Kffact_Final.csv')
head(kffact)
kffact = kffact[kffact$inStreamCat==0,]
lakedata = kffact[c(1,3)]
lakedata = kffact[c(1,10)]
rm(kffact)
imp = read.csv('L:/Priv/CORFiles/Geospatial_Library/Data/Project/LakeCat/FinalTables/ImperviousSurfaces2006_Final.csv')
lakedata$PctImp2006Ws = imp$PctImp2006Ws[match(lakedata$COMID, imp$COMID)]
rm(imp)
roaddens = read.csv('L:/Priv/CORFiles/Geospatial_Library/Data/Project/LakeCat/FinalTables/RoadDensity_Final.csv')
lakedata$RdDensWs = roaddens$RdDensWs[match(lakedata$COMID, roaddens$COMID)]
rm(roaddens)
lakedata$PctImp2006Ws[is.na(lakedata$PctImp2006Ws)] = 0
lakedata$RdDensWs[is.na(lakedata$RdDensWs)] = 0

# # Convert Impervious and Road Density to log scale
# lakedata$PctImp2006Ws[lakedata$PctImp2006Ws > 0] = log10(lakedata$PctImp2006Ws[lakedata$PctImp2006Ws > 0])
# lakedata$RdDensWs[lakedata$RdDensWs > 0] = log10(lakedata$RdDensWs[lakedata$RdDensWs > 0])

library(micromap)
# create map table
wsa.polys <- create_map_table(ageco, 'WSA9_NAME')
head(wsa.polys)
#change ID from factor to character
levels(as.factor(wsa.polys$ID))
levels(wsa.polys$ID) <- c("Coastal Plains","N. Appalachians","N. Plains","S. Appalachians","S. Plains", 
                          "T. Plains","Upper Midwest","W. Mountains","Xeric")
wsa.polys$ID <- as.character(wsa.polys$ID)
lakedata$WSA_NAME = lakes@data$WSA9_NAME[match(lakedata$COMID, lakes@data$COMID)]
levels(lakedata$WSA_NAME)
levels(lakedata$WSA_NAME) <- c("Coastal Plains","N. Appalachians","N. Plains","S. Appalachians","S. Plains", 
                          "T. Plains","Upper Midwest","W. Mountains","Xeric")

#now summarize data by aggregated ecoregions
#tip from Mike McManus via QuickR blog  http://statmethods.wordpress.com/
# define and name the statistics of interest  
stats <- function(x)(c(N = length(x), Mean = mean(x)))  

statsq <-function(x)(c(N = length(x), Min = min(x), Q1 = quantile(x,c(.25)),
                       Median = quantile(x,c(.5)), Q3 = quantile(x,c(.75)),
                       Max = max(x)))

library(reshape)
lakes.dfm   <- melt(lakedata,  
                      #outcome variables  
                      measure.vars = c("KffactWs","PctImp2006Ws","RdDensWs"),  
                      # classification variables  
                      id.vars = c("WSA_NAME"),  na.rm=TRUE)


lakes.dfc <- cast(lakes.dfm, WSA_NAME ~ variable, statsq)
names(lakes.dfc) <- c("WSA_NAME","KffactWs_N","KffactWs_Min","KffactWs_Q125","KffactWs_Median50","KffactWs_Q375","KffactWs_Max",
                      "PctImp2006Ws_N","PctImp2006Ws_Min","PctImp2006Ws_Q125","PctImp2006Ws_Median50","PctImp2006Ws_Q375","PctImp2006Ws_Max",
                      "RdDensWs_N","RdDensWs_Min","RdDensWs_Q125","RdDensWs_Median50","RdDensWs_Q375","RdDensWs_Max") 
lakes.dfc$WSA_NAME <- as.character(lakes.dfc$WSA_NAME)

lakes.dfc$points<-0

Kffact_Rd_Imp <- mmplot(stat.data=lakes.dfc, 
                 map.data=wsa.polys,
                 map.all=T,
                 plot.width=11,
                 panel.types=c('map', 'labels', 'box_summary', 'box_summary', 'box_summary'),
                 panel.data=list(NA,
                                 "WSA_NAME",
                                 list("KffactWs_Min", "KffactWs_Q125", "KffactWs_Median50", "KffactWs_Q375", "KffactWs_Max"),
                                 list("PctImp2006Ws_Min","PctImp2006Ws_Q125","PctImp2006Ws_Median50","PctImp2006Ws_Q375","PctImp2006Ws_Max"),
                                 list("RdDensWs_Min","RdDensWs_Q125","RdDensWs_Median50","RdDensWs_Q375","RdDensWs_Max")),
                 ord.by="KffactWs_Median50", 
                 grouping=3, 
                 median.row=F, 
                 map.link=c("WSA_NAME", 'ID'), 
                 panel.att=list(list(1, header='Light Gray Means\n Highlighted Above'), 
          #                            inactive.border.color=gray(.7), 
          #                            inactive.border.size=2), 
                                
                            list(2, header='Aggregated\n Ecoregions', 
                                 align='left', text.size=.6),
                            
                            list(3, header='Soil Erodibility',
                                 graph.bgcolor='lightgray',
                                 graph.bar.size = .6),
                            list(4, header='% Impervious Surfaces',
                                 graph.bgcolor='lightgray',
                                 graph.bar.size = .6),
                            list(5, header='Road Density',
                                 graph.bgcolor='lightgray',
                                 graph.bar.size = .6)))
print(Kffact_Rd_Imp, name='Kffact_Rd_Imp.png',res=1200)
```

### Percent Urban, Percent Ag, and Percent Forested for all lakes
```{r, message=FALSE, error=FALSE}
load("H:/WorkingData/lakes.RData")
#load("//aa.ad.epa.gov/ord/COR/Users/M-Z/mweber/Net MyDocuments/Publications/Wiley StatRef Article/MicromapExample_wsa.RData")
nlcd = read.csv('L:/Priv/CORFiles/Geospatial_Library/Data/Project/LakeCat/FinalTables/NLCD2006_Final.csv')
head(nlcd)
nlcd$PctUrb = nlcd$PctUrbLo2006Ws + nlcd$PctUrbMd2006Ws + nlcd$PctUrbHi2006Ws
nlcd$PctAg = nlcd$PctCrop2006Ws
nlcd$PctFor = nlcd$PctDecid2006Ws + nlcd$PctConif2006Ws + nlcd$PctMxFst2006Ws
nlcd = nlcd[nlcd$inStreamCat==0,]
lakedata = nlcd[c(1,3,39:41)]


lakedata$PctUrb[is.na(lakedata$PctUrb)] = 0
lakedata$PctAg[is.na(lakedata$PctAg)] = 0
lakedata$PctFor[is.na(lakedata$PctFor)] = 0


library(micromap)
# create map table
wsa.polys <- create_map_table(ageco, 'WSA9_NAME')
head(wsa.polys)
#change ID from factor to character
levels(as.factor(wsa.polys$ID))
levels(wsa.polys$ID) <- c("Coastal Plains","N. Appalachians","N. Plains","S. Appalachians","S. Plains", 
                          "T. Plains","Upper Midwest","W. Mountains","Xeric")
wsa.polys$ID <- as.character(wsa.polys$ID)
lakedata$WSA_NAME = lakes@data$WSA9_NAME[match(lakedata$COMID, lakes@data$COMID)]
levels(lakedata$WSA_NAME)
levels(lakedata$WSA_NAME) <- c("Coastal Plains","N. Appalachians","N. Plains","S. Appalachians","S. Plains", 
                          "T. Plains","Upper Midwest","W. Mountains","Xeric")

# Create 'low', 'med','high' categories for land use groups
library(classInt)
# Urban
classIntervals(lakedata$PctUrb[lakedata$PctUrb>0], 3, style='quantile')
# assign percentage values to our categories
lakedata$UrbCat <- cut(lakedata$PctUrb, breaks=c(0, .5, 2, 100), include.lowest=TRUE)
levels(lakedata$UrbCat)
levels(lakedata$UrbCat) = c('Low','Med','High')
summary(lakedata$UrbCat)
lakedata$UrbCat = as.character(lakedata$UrbCat)
lakedata$UrbCat[is.na(lakedata$UrbCat)] = 'Low'
# Ag
classIntervals(lakedata$PctAg[lakedata$PctAg>0], 3, style='quantile')
# assign percentage values to our categories
lakedata$AgCat <- cut(lakedata$PctAg, breaks=c(0, 10, 50, 100), include.lowest=TRUE)
levels(lakedata$AgCat)
levels(lakedata$AgCat) = c('Low','Med','High')
summary(lakedata$AgCat)
lakedata$AgCat = as.character(lakedata$AgCat)
lakedata$AgCat[is.na(lakedata$AgCat)] = 'Low'

library(dplyr)
urb = lakedata %>%
  group_by(WSA_NAME, UrbCat) %>%
  summarise (n = n()) %>%
  mutate(freq = (n / sum(n)*100)) 
Ag = lakedata %>%
  group_by(WSA_NAME, AgCat) %>%
  summarise (n = n()) %>%
  mutate(freq = (n / sum(n)*100))
landcov = data.frame(urb)
names(landcov)[3:4] = c('n.urb','freq.urb')
Ag = data.frame(Ag)
names(Ag)[3:4] = c('n.ag','freq.ag')
landcov = cbind(landcov, Ag[,3:4])

levels(as.factor(landcov$UrbCat))
landcov$UrbCat = factor(landcov$UrbCat, levels=c("Low","Med","High"))
landcov = landcov[order(landcov$WSA_NAME,landcov$UrbCat),]
NLCD_mmap <- mmgroupedplot(stat.data=landcov,
              map.all=T,
              map.data=wsa.polys,
              panel.types=c("map", "labels", "bar_cl", "bar_cl"),
              panel.data=list(NA,"UrbCat",
                              list("freq.urb","freq.urb","freq.urb"),
                              list("freq.ag","freq.ag","freq.ag")),
              grp.by="WSA_NAME",
              cat="UrbCat",
              colors=c("green3","lightblue","red3"),
              map.color="orange3",
              map.link=c("WSA_NAME", "ID"),
              plot.grp.spacing=1,
              plot.width=10,
              plot.height=7,
              panel.att=list(list(1, header="Region", header.size=1,
              panel.width=.6),
              list(2, header="Category",
              header.size=1,
              panel.width=.4,
              text.size = .6),
              list(3, header="Urban", header.size=1,
              xaxis.title="percent"),
              list(4, header="Ag", header.size=1,
              xaxis.title="percent")))
print(NLCD_mmap, name='NLCD_mmap.png',res=1200)
```


### Try out some other ideas
```{r, message=FALSE, error=FALSE}
library(ggplot2)
nlcd = read.csv('L:/Priv/CORFiles/Geospatial_Library/Data/Project/LakeCat/FinalTables/NLCD2006_Final.csv')
head(nlcd)
nlcd$PctUrb = nlcd$PctUrbLo2006Ws + nlcd$PctUrbMd2006Ws + nlcd$PctUrbHi2006Ws
nlcd$PctAg = nlcd$PctCrop2006Ws
nlcd$PctFor = nlcd$PctDecid2006Ws + nlcd$PctConif2006Ws + nlcd$PctMxFst2006Ws
nlcd = nlcd[nlcd$inStreamCat==0,]
lakedata = nlcd[c(1,39:41)]
lakedata$WsAreaBin <- cut(lakedata$WsAreaSqKm, quantile(lakedata$WsAreaSqKm), include.lowest=TRUE)
levels(lakedata$WsAreaBin) <- list('<25th'=c("[0.0036,0.968]"), '50-75th'=c("(0.968,3.31]", "(3.31,13.8]"), '>75th' = c("(13.8,3.13e+06]"))
lakedata$WSA_NAME = lakes@data$WSA9_NAME[match(lakedata$COMID, lakes@data$COMID)]
f <- function(x) {
  r <- quantile(x, probs = c(0.10, 0.25, 0.5, 0.75, 0.90))
  names(r) <- c("ymin", "lower", "middle", "upper", "ymax")
  r
}

p <- ggplot(lakedata, aes(WsAreaBin,PctAg))
p + stat_summary(fun.data = f, geom="boxplot") + facet_wrap(~ WSA_NAME, ncol=2)
# p + geom_boxplot() + facet_wrap(~ WSA_NAME, ncol=2)

```